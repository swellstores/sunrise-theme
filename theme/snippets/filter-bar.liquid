{%- liquid
  assign color_scheme = color_scheme
  assign sort_by = results.sort_by | default: results.default_sort_by
  assign request_path = results.url | default: request.path
-%}

<filter-drawer-root class="text-{{ color_scheme }}">
  <button
    data-trigger="filter-drawer"
    type="button"
    aria-expanded="false"
    class="inline-block text-title-small font-display"
  >
    <span class="flex gap-8 items-center">
      {{- 'filter-sort-icon.svg' | inline_asset_content -}}
      {{ 'sections.collection.filters.filter_and_sort' | t -}}
    </span>
  </button>

  <!-- Filter drawer -->
  <div
    data-target="filter-drawer"
    class="fixed top-0 left-0 h-full w-340 lg:w-400 bg-white hidden"
    style="z-index: 5000"
    role="dialog"
    aria-modal="true"
    aria-expanded="false"
  >
    <div class="flex flex-col h-full">
      <!-- Header -->
      <div class="flex items-center justify-between p-24 border-b border-gray-200">
        <h3 class="font-display filter-drawer-title">{{ 'sections.collection.filters.filters' | t }}</h3>
        <button
          data-trigger="filter-drawer"
          type="button"
          class="flex h-40 items-center justify-center"
        >
          <span class="sr-only">{{ 'sections.collection.filters.close' | t }}</span>
          <ion-icon name="close" aria-hidden="true" class="w-24 h-24"></ion-icon>
        </button>
      </div>

      <!-- Filters Form -->
      <form
        id="filter-form-stack"
        class="flex-1 overflow-y-auto"
        hx-get="{{ request_path }}"
        hx-trigger="change"
        hx-target="#results"
        hx-select="#results"
        hx-swap="outerHTML"
        hx-sync="this:replace"
      >
        <div class="px-24">
          {% for filter in results.filters %}
            <details
              class="filter-section"
              open
            >
              <summary class="flex items-center justify-between py-18 list-none cursor-pointer">
                <h4 class="filter-title font-display">{{ filter.label }}</h4>
                <ion-icon
                  name="chevron-down-outline"
                  aria-label="{{ 'general.accordion.toggle' | t }}"
                  class="h-20 w-20 transition-transform"
                ></ion-icon>
              </summary>
              <div class="filter-options">
                {% if filter.type == 'list' %}
                  <div class="flex flex-col">
                    <!-- "All" option -->
                    <label class="flex items-center flex-nowrap filter-checkbox-height">
                      <input
                        type="checkbox"
                        class="size-16 mr-6 rounded border-gray-300 all-checkbox"
                        name="{{ filter.param_name }}_all"
                        value="all"
                        data-filter-group="{{ filter.param_name }}"
                      >
                      <span class="font-display text-nowrap">All</span>
                    </label>
                    {% for option in filter.values %}
                      {% render 'filter-input', filter: filter, option: option %}
                    {% endfor %}
                  </div>
                {% else %}
                  {% render 'filter-input', filter: filter %}
                {% endif %}
              </div>
            </details>
          {% endfor %}
        </div>
      </form>

      <!-- Add submit button as fallback -->
      <div class="p-24">
        <button
          type="submit"
          form="filter-form-stack"
          class="w-full py-12 px-24 bg-black text-white text-body-large font-display"
          onclick="prepareFormSubmission()"
        >
          View results
        </button>
      </div>
    </div>
  </div>

  <!-- Active filters -->
  <section aria-labelledby="filter-heading">
    <h2 id="filter-heading" class="sr-only">{{ 'sections.collection.filters.filters' | t }}</h2>

    <!-- Active filter list -->
    {% liquid
      assign active_filter_count = 0
      assign active_price_range = false
      for filter in results.filters
        if filter.type == 'price_range'
          if filter.min_value.value or filter.max_value.value
            assign active_filter_count = active_filter_count | plus: 1
            assign active_price_range = true
          endif
        else
          if filter.active_values.size > 0
            assign active_filter_count = active_filter_count | plus: 1
          endif
        endif
      endfor
    %}

    <div id="active-filters" hx-swap-oob="true">
      {% if active_filter_count > 0 %}
        <div class="bg-{{ color_scheme }} py-12 sm:flex sm:justify-between sm:items-center">
          <span class="sr-only">{{ 'sections.collection.filters.active' | t }}</span>
          <div class="-m-4 flex flex-wrap items-center">
            {% for filter in results.filters %}
              {% if filter.type == 'price_range' %}
                {% if active_price_range %}
                  {% render 'filter-tag', filter: filter, color_scheme: color_scheme %}
                {% endif %}
              {% else %}
                <!-- DEBUG: Show filter info -->
                {% comment %} DEBUG: {{ filter.label }} has {{ filter.active_values.size }} active values {% endcomment %}
                {% for value in filter.active_values %}
                  {% render 'filter-tag', filter: filter, value: value, color_scheme: color_scheme %}
                {% endfor %}
              {% endif %}
            {% endfor %}
          </div>
          <div class="clear-all">
            <a
              href="{{ results.url }}"
              class="text-{{ color_scheme }} underline-offset-2 hover:underline"
              hx-boost="true"
              hx-push-url="true"
              hx-target="#results"
              hx-select="#results"
              hx-swap="outerHTML"
            >
              {{ 'sections.collection.filters.clear_all' | t }}
            </a>
          </div>
        </div>
      {% else %}
        <!-- Empty state to ensure out-of-band swap works -->
        <div style="display: none;"></div>
      {% endif %}
    </div>
  </section>
</filter-drawer-root>

<script>
  let filterInitialized = false;
  let isFormSubmitting = false;
  let formSubmissionTimestamp = 0;

  function initializeFilters() {
    if (filterInitialized) return;
    filterInitialized = true;

    document.addEventListener('htmx:afterSwap', handleAfterSwap);
    document.body.addEventListener('htmx:beforeRequest', handleBeforeRequest);
    document.addEventListener('htmx:afterRequest', handleAfterRequest);
    document.addEventListener('htmx:configRequest', handleConfigRequest);
    document.addEventListener('priceSliderChanged', () => updateOpacity(true));
    document.addEventListener('htmx:oobAfterSwap', handleOobAfterSwap);
    document.addEventListener('change', handleCheckboxChange);

    setupInitialState();
  }

  let savedCheckboxStates = new Map();

  function saveCheckboxStates() {
    const filterForm = document.querySelector('#filter-form-stack');
    if (!filterForm) return;

    const checkboxes = filterForm.querySelectorAll('input[type="checkbox"]');
    savedCheckboxStates.clear();

    checkboxes.forEach((checkbox) => {
      savedCheckboxStates.set(checkbox.name + '|' + checkbox.value, checkbox.checked);
    });
  }

  function restoreCheckboxStates() {
    const filterForm = document.querySelector('#filter-form-stack');
    if (!filterForm || savedCheckboxStates.size === 0) return;

    const checkboxes = filterForm.querySelectorAll('input[type="checkbox"]');
    let restoredCount = 0;

    checkboxes.forEach((checkbox) => {
      const key = checkbox.name + '|' + checkbox.value;
      if (savedCheckboxStates.has(key)) {
        checkbox.checked = savedCheckboxStates.get(key);
        restoredCount++;
      }
    });
  }

  function handleAfterSwap(event) {
    const now = Date.now();
    const timeSinceFormSubmission = now - formSubmissionTimestamp;
    const isOutOfBandSwap = event.detail.isOOB === true;
    const isMainResultsSwap = event.target && event.target.id === 'results';
    const isFilterFormSwap = event.target && event.target.closest('#filter-form-stack');

    const requestPath = event.detail.xhr?.responseURL || '';
    const hasFilterParams = requestPath.includes('filter_') || requestPath.includes('price');
    const isFormRelatedSwap =
      (formSubmissionTimestamp > 0 && timeSinceFormSubmission < 10000) || isFormSubmitting || hasFilterParams;

    if (isFormRelatedSwap) {
      restoreCheckboxStates();
    } else {
      syncCheckboxStates();
      isFormSubmitting = false;
      formSubmissionTimestamp = 0;
    }

    updateOpacity(false);

    if (window.initPriceSliders) {
      window.initPriceSliders();
    }

    if (window.filters) {
      window.filters();

      if (isFormRelatedSwap) {
        setTimeout(() => {
          restoreCheckboxStates();
        }, 10);
      }
    }
  }

  function handleBeforeRequest(event) {
    saveCheckboxStates();

    if (event.target.id === 'filter-form-stack') {
      isFormSubmitting = true;
      formSubmissionTimestamp = Date.now();
    }

    updateOpacity(true);
  }

  function handleAfterRequest(event) {
    updateOpacity(false);
    
    if (isFormSubmitting) {
      setTimeout(() => {
        isFormSubmitting = false;
        formSubmissionTimestamp = 0;
      }, 6000);
    }
  }

  function handleConfigRequest(event) {
    if (window.onHtmxConfigRequest) {
      window.onHtmxConfigRequest(event);
    }

    const form = event.target.closest('form');
    if (!form || form.id !== 'filter-form-stack') return;

    const allCheckboxes = form.querySelectorAll('input[name$="_all"]:checked');
    
    allCheckboxes.forEach((allCheckbox) => {
      const filterGroup = allCheckbox.dataset.filterGroup;
      if (filterGroup) {
        delete event.detail.parameters[allCheckbox.name];
        
        const groupCheckboxes = form.querySelectorAll(`input[name="${filterGroup}"]`);
        groupCheckboxes.forEach((groupCheckbox) => {
          if (!groupCheckbox.name.endsWith('_all')) {
            delete event.detail.parameters[groupCheckbox.name];
          }
        });
      }
    });
  }

  function handleOobAfterSwap(event) {
    const element = event.target;

    if (
      element &&
      (element.id === 'filter-form-bar' ||
        element.closest('#filter-form-stack') ||
        element.querySelector('#filter-form-stack'))
    ) {
      setTimeout(() => {
        restoreCheckboxStates();
      }, 50);

      if (window.filters) {
        window.filters();

        if (isFormSubmitting) {
          setTimeout(() => {
            restoreCheckboxStates();
          }, 10);
        }
      }
    }

    if (element && element.id === 'active-filters') {
      if (isFormSubmitting) {
        setTimeout(() => {
          restoreCheckboxStates();
        }, 50);
      }
    }
  }

  function updateOpacity(loading) {
    const results = document.querySelector('#results');
    if (results) {
      if (loading) {
        results.classList.add('opacity-20');
      } else {
        results.classList.remove('opacity-20');
      }
    }
  }

  function handleCheckboxChange(event) {
    const checkbox = event.target;

    if (checkbox.type !== 'checkbox' || !checkbox.closest('#filter-form-stack')) {
      return;
    }

    if (checkbox.name.endsWith('_all')) {
      handleAllCheckboxChange(checkbox);
    } else {
      handleRegularCheckboxChange(checkbox);
    }
    
    saveCheckboxStates();
  }

  function handleAllCheckboxChange(checkbox) {
    if (!checkbox.checked) return;

    const filterGroup = checkbox.dataset.filterGroup;
    const filterForm = document.querySelector('#filter-form-stack');
    
    if (!filterForm || !filterGroup) return;

    const otherCheckboxes = filterForm.querySelectorAll(`input[name="${filterGroup}"]`);
    otherCheckboxes.forEach((otherCheckbox) => {
      if (otherCheckbox !== checkbox && !otherCheckbox.name.endsWith('_all')) {
        otherCheckbox.checked = false;
      }
    });
  }

  function handleRegularCheckboxChange(checkbox) {
    const filterForm = document.querySelector('#filter-form-stack');
    if (!filterForm) return;

    const filterGroup = checkbox.name;
    const allCheckbox = filterForm.querySelector(`input[name="${filterGroup}_all"]`);
    
    if (!allCheckbox) return;

    if (checkbox.checked) {
      allCheckbox.checked = false;
    } else {
      const otherCheckboxes = filterForm.querySelectorAll(`input[name="${filterGroup}"]`);
      const allUnchecked = Array.from(otherCheckboxes).every((otherCheckbox) => {
        return otherCheckbox === checkbox || otherCheckbox.name.endsWith('_all') || !otherCheckbox.checked;
      });
      
      if (allUnchecked) {
        allCheckbox.checked = true;
      }
    }
  }

  function syncCheckboxStates() {
    if (isFormSubmitting || (formSubmissionTimestamp > 0 && Date.now() - formSubmissionTimestamp < 5000)) {
      return;
    }

    const filterForm = document.querySelector('#filter-form-stack');
    if (!filterForm) {
      return;
    }

    const params = new URLSearchParams(window.location.search);
    const checkboxes = filterForm.querySelectorAll('input[type="checkbox"]');

    checkboxes.forEach((checkbox) => {
      const paramName = checkbox.name;
      const paramValue = checkbox.value;

      if (paramName.endsWith('_all')) {
        const filterGroup = paramName.replace('_all', '');
        const hasOtherSelections = params.has(filterGroup);
        const shouldBeChecked = !hasOtherSelections;

        checkbox.checked = shouldBeChecked;
      } else {
        const shouldBeChecked = params.has(paramName) && params.getAll(paramName).includes(paramValue);

        checkbox.checked = shouldBeChecked;
      }
    });
  }

  function setupInitialState() {
    const filterForm = document.querySelector('#filter-form-stack');
    if (!filterForm) return;

    const allCheckboxes = filterForm.querySelectorAll('input[name$="_all"]');
    allCheckboxes.forEach((checkbox) => {
      checkbox.checked = true;
    });

    const params = new URLSearchParams(window.location.search);
    const hasAnyFilters = Array.from(params.keys()).some((key) => key.includes('filter_') || key.includes('price'));

    if (hasAnyFilters) {
      syncCheckboxStates();
    }
  }

  function prepareFormSubmission() {
    const form = document.querySelector('#filter-form-stack');
    if (!form) return;

    const allCheckboxes = form.querySelectorAll('input[name$="_all"]');
    allCheckboxes.forEach((checkbox) => {
      if (checkbox.checked) {
        checkbox.disabled = true;
      }
    });

    setTimeout(() => {
      allCheckboxes.forEach((checkbox) => {
        checkbox.disabled = false;
      });
    }, 100);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeFilters);
  } else {
    initializeFilters();
  }
</script>

{{ 'filter.js' | asset_url | script_tag }}

{% style %}
  .filter-section:first-child {
    margin-top: 0;
  }

  .filter-section[open] summary ion-icon {
    transform: rotate(180deg);
  }

  .filter-drawer-title {
    font-size: 18px;
    font-weight: 500;
    line-height: 24px;
  }

  .filter-title {
    font-size: 16px;
    font-weight: 500;
    line-height: 20px;
  }

  input[type='checkbox'] {
    width: 16px;
    height: 16px;
    border-radius: 2px;
    appearance: none;
    background-color: #fff;
    display: inline-block;
    cursor: pointer;
    border: 1px solid #222222;
    position: relative;
  }

  input[type='checkbox']:checked {
    background-color: #222222;
    border-color: #222222;
  }

  input[type='checkbox']:checked::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 10px;
    height: 6px;
    border: 2px solid #fff;
    border-top: 0;
    border-right: 0;
    transform: translate(-50%, -65%) rotate(-45deg);
  }

  input[type='checkbox']:disabled {
    background-color: #e5e5e5;
    border-color: #e5e5e5;
    cursor: not-allowed;
  }

  .filter-checkbox-height {
    height: 3rem;
  }

  .filter-count-badge {
    background-color: #f3f4f6;
    width: 2.4rem;
    height: 2.4rem;
    border-radius: 0.4rem;
    font-size: 1.2rem;
    line-height: 1.6rem;
    color: #757575;
    display: flex;
    align-items: center;
    justify-content: center;
  }
{% endstyle %}
